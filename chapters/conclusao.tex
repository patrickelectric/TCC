\chapter{Experimento e Resultados}
Finalizada a fase de desenvolvimento da ferramenta, uma fase de testes foi iniciada com intuito de validar a ferramenta desenvolvida.

\section{Ambiente Experimental}

Todas as placas foram programas com o plugin desenvolvido utilizando um computador com o sistema operacional Linux, com o SDK do Arduino versão 1.6.10. A versão do KDevelop utilizado com o plugin foi a 5.0.0, contendo as atualizações da versão do QT 5.8 assim como uma boa parte do código migrado para C++11.

\subsection{Hardware Utilizado}

Os processos de gravação foram realizados via USB, por intermédio de um hardware especializado para realizar a gravação ou um adaptador serial-USB para permitir uma comunicação do software de programação para com o \textit{bootloader}.

O Arduino Mega possui um processador ATmega2560, com 10 entradas analógicas a mais que o Arduino UNO, com 54 pinos digitais, 15 com função de \textit{PWM} e contendo um grande vantagem em memória \textit{RAM} e \textit{EEPROM}.

\abreviatura{RAM}{\textit{Random Access Memory}}


O Arduino Nano Por ser uma placa de desenvolvimento completa, com um tamanho de aproximadamente um quarto do Arduino UNO, se tornou muito popular pela mobilidade e facilidade de desenvolvimento, assim como o \textit{pinout}\footnote{ Referencia utilizada para equidistância entre os pinos ou conexões.} ideal para ser encaixado numa \textit{protoboard}\footnote{Matriz de contato, utilizada para realizar ensaios de circuitos, contem contatos e conexões para montagem.}. Além disso, alguns modelos tem dois pinos a mais de entrada analógica comparado com o Arduino Pro Mini e Arduino UNO.

Desenvolvido para aplicações com pouco espaço e para instalações permanentes, o Arduino pro mini utiliza um processador ATmega328,  diferente de outras placas da Arduino, está não possui um hardware assistencialista para a realização do \textit{upload} do processador na própria placa, logo, tal artefato, necessita ser conectado na placa para realizar a sua programação, apesar disso, contem as demais características do Arduino UNO.

Sendo a placa de desenvolvimento de lançamento comemorativa do lançamento oficial do arduino, o Arduino UNO utiliza o processador ATmega328P, sendo a primeira que utiliza USB para realizar o \textit{upload} do código de máquina para o processador via \textit{bootloader}. Contem 6 entradas analógicas, 14 pinos digitais, 6 pinos de \textit{PWM}, 1kb de \textit{SRAM}, 2kb de \textit{EEPROM}, 32kb de flash e 1 serial em hardware. Muito similar ao Arduino Nano, porém, conta com duas portas analógicas a menos.

\abreviatura{SRAM}{\textit{{Static Random Access Memory}}}
\abreviatura{EEPROM}{\textit{Electrically-Erasable Programmable Read-Only Memory}}

ARM é uma arquitetura baseada na família RISC de processadores, onde as instruções tendem a ser operações simples, onde as mais complexas são quebradas até chegar em instruções uno.

Atualmente é considera a arquitetura mais popular entre sistemas computacionais após a revolução \textit{mobile} dos telefones e \textit{smartphones}.

Muitas placas de desenvolvimento, tanto para profissionais quanto para hobbistas possuem processadores ARM ou variantes que utilizam este mesmo processador, tanto para usos em \textit{bere-metal} quanto para usos com sistema operacional.

\abreviatura{RISC}{\textit{Reduced Instruction Set}}

O STM32 se trata de uma família de processadores da arquitetura ARM de 32-bits pertencentes a empresa STMicroelectronics. O Cortex-M, cerne do processador, pode ser encontrado em alguns processadores conhecidos como: Cortex-M0, Cortex-M1, Cortex-M3, Cortex-M4, Cortex-M7 entre outros. Sendo todos distintos pelo hardware de suporte a CPU, podendo ter FPU, decodificação de instruções de DSP, eficiência energética e etc.

\abreviatura{FPU}{\textit{Float Point Unit}}
\abreviatura{DSP}{\textit{Digital Signal Processing}}
%\itodo{Adicionar fotos da placa}

\section{Testes Realizados}

Todos os testes foram realizados utilizando o \textit{commit-id}\footnote{Identificação utilizando \textit{SHA-1 hash} do conteúdo do commit, data, mensagem de log, id do commit anterior, entre outros.} 716f4cb474-\\f45557345e64762cb029d90874d96f.

\subsection{Interface}
A realização dos testes para interface gráfica foram feitos com os seguintes itens.
\begin{itemize}
\item \textit{First-Time Configuration}
\subitem É realizado o teste quando selecionado um diretório, evitando pastas invalidas.
\subitem O Download só é realizado com acesso a internet, caso a conexão seja interrompida ou inexistente, uma reinicialização do download necessita ser realizada manualmente.
\item  \textit{Board Settings}
\subitem Por
\end{itemize}

\subsection{Carregamento}
Inicialmente foram avaliados alguns modelos de Arduíno, entre as versões atuais, as utilizadas foram: Arduino nano, Arduino Mini e Arduino Mega.

Para demonstrar o funcionamento minimo do sistema, foi utilizado o projeto Arduino-Makefile\footnote{\url{https://github.com/sudar/Arduino-Makefile}} com o exemplo de piscar o LED (Algoritmo 6.1) em todas as placas da Arduino.

\lstinputlisting[language=C++,caption={blink.ino},label=blink]{blink.ino}

O código foi compilado e enviado para todas as placas, executando o código de piscar o LED.

No teste do \textit{OpenOCD}, foi utilizado um projeto exemplo de piscar o LED da placa de desenvolvimento STM32F4DISCOVERY (Algoritmo 6.2)

\lstinputlisting[language=C++,caption={project.c},label=blink2]{blink2.cpp}

O Código foi compilado e enviado para a placa, tendo como resultado o piscar do LED.

\subsection{Depuração}
Entre os sistemas suportados, o \textit{OpenOCD} é o único que tem suporte a depuração de sistemas embarcados. Para realizar tal operação é necessário manter o \textit{OpenOCD} enquanto a conexão do GDB é realizada.

\chapter{Conclusão}
Dentro do período de desenvolvimento, o plugin alcançou todas as expectativas traçadas,
permitindo a gravação dos sistemas embarcados utilizando o KDevelop, mesmo necessitando algumas modificações para ficar
totalmente integrado ao fluxo de trabalho.

A integração com o KDevelop foi realizada com sucesso, necessitando que o usuário configure algumas variáveis para permitir identificar o hardware utilizado pelo mesmo, tanto o processador quanto o hardware especialista ou assistencialista na realização do envio do código binário.

O código fonte do projeto desenvolvido pode ser encontrado no \textit{mirror} do \textit{GitHub} (\url{https://github.com/KDE/kdev-embedded/tree/master}) ou no repositório oficial do \textit{phabricator} (\url{https://phabricator.kde.org/source/kdev-embedded/browse/master/}).

Tendo em vista que com o suporte para as placas da \textit{Arduino} e do sistema \textit{OpenOCD} realizado, ainda é necessário mais alguns trabalhos relacionados a áreas especificas.

As interfaces desenvolvidas foram trabalhadas para serem a mais ami-gáveis e altamente configuráveis na medida do possível, contudo, ainda é necessário um polimento e melhor desenvolvimento tanto da interface do plugin quanto do KDevelop, para permitir uma melhor integração com o usuário, facilitando algumas configurações básicas como a já existentes no \textit{eclipse IDE} para \textit{debug} remoto.

Mesmo o instalador sendo completamente funcional, identificando ver-sões instaladas no sistema operacional e
permitindo ao usuário realizar a instalação automática das dependências, com a ajuda da interface gráfica disponível pelo plugin, o mesmo não é de muita ajuda para os usuários avançados.

A integração do plugin desenvolvido com os demais plugins do KDevelop necessita ser melhor integrado e aprimorada, permitindo desta
forma a integração com os gerenciadores de montagem de software.

Atualmente o plugin utiliza uma biblioteca desenvolvida pela comunidade do KDE conhecida como \textit{Solid}, onde permite uma boa integração com o \textit{hardwre} do computador onde o mesmo está sendo executado. Contudo o mesmo tem problemas para identificação de gravadores que não utilizam um adaptador Adaptador Serial-USB, dificultando sua utilização. 

Como proposta de solução, é utilizar os valores de PID e VID dos dispositivos conhecidos na realização da gravação, podendo ser obtidos através das bibliotecas do \textit{OpenOCD}, para melhorar sua utilização na detecção de hardware.

\abreviatura{PID}{\textit{Product ID}}
\abreviatura{VID}{\textit{Vendor ID}}
