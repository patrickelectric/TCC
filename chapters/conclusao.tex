\chapter{Experimento e Resultados}
Finalizada a fase de desenvolvimento da ferramenta, uma fase de testes foi iniciada com intuito de validar a ferramenta desenvolvida.

\section{Ambiente Experimental}

Todas as placas foram programas com o plugin desenvolvido utilizando um computador com o sistema operacional Linux, com o SDK do Arduino versão 1.6.10. A versão do KDevelop utilizado com o plugin foi a 5.0.0, contendo as atualizações da versão do QT 5.8 assim como uma boa parte do código migrado para C++11.

\subsection{Hardware Utilizado}

Os processos de gravação foram realizados via USB, por intermédio de um hardware especializado para realizar a gravação ou um adaptador serial-USB para permitir uma comunicação do software de programação para com o \textit{bootloader}.

O Arduino Mega possui um processador ATmega2560, com 10 entradas analógicas a mais que o Arduino UNO, com 54 pinos digitais, 15 com função de \textit{PWM} e contendo um grande vantagem em memória \textit{RAM} e \textit{EEPROM}.

\abreviatura{RAM}{\textit{Random Access Memory}}


O Arduino Nano Por ser uma placa de desenvolvimento completa, com um tamanho de aproximadamente um quarto do Arduino UNO, se tornou muito popular pela mobilidade e facilidade de desenvolvimento, assim como o \textit{pinout}\footnote{ Referencia utilizada para equidistância entre os pinos ou conexões.} ideal para ser encaixado em uma \textit{protoboard}\footnote{Matriz de contato, utilizada para realizar ensaios de circuitos, contem contatos e conexões para montagem.}. Além disso, alguns modelos tem dois pinos a mais de entrada analógica comparado com o Arduino Pro Mini e Arduino UNO.

Desenvolvido para aplicações com pouco espaço e para instalações permanentes, o Arduino pro mini utiliza um processador ATmega328,  diferente de outras placas da Arduino, está não possui um hardware assistencialista para a realização do \textit{upload} do processador na própria placa, logo, tal artefato, necessita ser conectado na placa para realizar a sua programação, apesar disso, contem as demais características do Arduino UNO.

Sendo a placa de desenvolvimento de lançamento comemorativa do lançamento oficial do arduino, o Arduino UNO utiliza o processador ATmega328P, sendo a primeira que utiliza USB para realizar o \textit{upload} do código de máquina para o processador via \textit{bootloader}. Contem 6 entradas analógicas, 14 pinos digitais, 6 pinos de \textit{PWM}, 1kb de \textit{SRAM}, 2kb de \textit{EEPROM}, 32kb de flash e 1 serial em hardware. Muito similar ao Arduino Nano, porém, conta com duas portas analógicas a menos.

\abreviatura{SRAM}{\textit{{Static Random Access Memory}}}
\abreviatura{EEPROM}{\textit{Electrically-Erasable Programmable Read-Only Memory}}

ARM é uma arquitetura baseada na família RISC de processadores, onde as instruções tendem a ser operações simples, onde as mais complexas são quebradas até chegar em instruções uno.

Atualmente é considera a arquitetura mais popular entre sistemas computacionais após a revolução \textit{mobile} dos telefones e \textit{smartphones}.

Muitas placas de desenvolvimento, tanto para profissionais quanto para hobbistas possuem processadores ARM ou variantes que utilizam este mesmo processador, tanto para usos em \textit{bere-metal} quanto para usos com sistema operacional.

\abreviatura{RISC}{\textit{Reduced Instruction Set}}

O processador LX4f232H (Cortex-M4) se trata de um processador da arquitetura ARM de 32-bits pertencentes a empresa STMicroelectronics. O Cortex-M, cerne do processador, pode ser encontrado em alguns processadores conhecidos como: Cortex-M0, Cortex-M1, Cortex-M3, Cortex-M4, Cortex-M7 entre outros. Sendo todos distintos pelo hardware de suporte a CPU, podendo ter FPU, decodificação de instruções de DSP, eficiência energética e etc.

\abreviatura{FPU}{\textit{Float Point Unit}}
\abreviatura{DSP}{\textit{Digital Signal Processing}}
%\itodo{Adicionar fotos da placa}

\section{Testes Realizados}

Todos os testes foram realizados utilizando o \textit{commit-id}\footnote{Identificação utilizando \textit{SHA-1 hash} do conteúdo do commit, data, mensagem de log, id do commit anterior, entre outros.} 716f4cb474-\\f45557345e64762cb029d90874d96f.

\subsection{Interface}
A realização dos testes para interface gráfica foram feitos com os seguintes itens.
\begin{itemize}
\item \textit{First-Time Configuration}
\subitem É realizado o teste quando selecionado um diretório, evitando pastas invalidas.
\subitem O Download só é realizado com acesso a internet, caso a conexão seja interrompida ou inexistente, uma reinicialização do download necessita ser realizada manualmente.

\item  \textit{Board Settings}
\subitem Por utilizar opções predefinidas nos arquivos de configuração do Arduino, a única opção de entrada do usuário é a seleção da porta de comunicação e do arquivo binário. 
\subitem Não é identificado o sistema embarcado pela porta de comunicação, sendo assim o usuário necessita saber qual porta deverá ser selecionada. O retorno do gravador ajuda ao usuário identificar algum problema de porta ou hardware.
\subitem O arquivo de código de maquina não é testado, possibilitando ao usuário selecionar arquivos indesejados. O gravador irá retornar um erro para o usuário, identificando o arquivo como não suportado
\subitem Não é possível para o usuário selecionar portas incorretas (bluetooth, mouse, teclado), pois os hardware selecionados são identificados pelo valor de PID (\textit{Product ID}) e VID (\textit{Vendor ID}) do dispositivo USB.

\item  \textit{Configure Launchs}
\subitem Por se tratar de um menu de configuração mais avançada, foi optado por permitir ao usuário mais liberdade nas opções, podendo editar todas as opções de forma textual. A Liberdade na configuração das expressões acarreta em uma certa responsabilidade do usuário, consequentemente, podendo acarretar em erros se os termos forem mais empregados.
\subitem As configurações determinadas pela própria ferramenta do Arduino podem ser escolhidas e editadas, podendo acarretar nos problemas ditos anteriormente.

\end{itemize}

\subsection{Carregamento}
Inicialmente foram avaliados alguns modelos de Arduíno, entre as versões atuais, as utilizadas foram: Arduino nano, Arduino Mini e Arduino Mega.

Para demonstrar o funcionamento minimo do sistema, foi utilizado o projeto Arduino-Makefile\footnote{\url{https://github.com/sudar/Arduino-Makefile}} com o exemplo de piscar o LED (Algoritmo 6.1) em todas as placas da Arduino.

\lstinputlisting[language=C++,caption={blink.ino},label=blink]{blink.ino}

O código foi compilado e enviado para todas as placas, executando o código de piscar o LED.

Também foi feito teste com outro código, Algoritmo 6.2, que tem como função o cálculo da função seno utilizando a série de Taylor, equação \ref{eq:sin}. O objetivo é provar o funcionamento de um código em C um pouco mais complexo.
\begin{equation}
sin(x) = \sum_{k=0}^{n} (-1)^k * \frac{x^{2*k+1}}{(2*k+1)!}
\label{eq:sin} 
\end{equation}
\lstinputlisting[language=C++,caption={sin.ino},label=sin]{sin.ino}.
O resultado para o seno de $\frac{\pi}{4}$ utilizando uma soma de 20 termos foi o valor $0.7071066856$, enquanto o valor real é $0.7071067811..$ mostrando uma solução com 
$99.9999865\%$ de precisão.

Foi realizado um teste utilizando C++11 para provar o funcionamento das bibliotecas STL e função mais novas da linguagem. O Algoritmo 6.3 mostra o código utilizado.

\lstinputlisting[language=C++,caption={cpp.ino},label=cpp]{cpp.ino}.

O resultado foi a contagem dos itens da lista, mostrando o id de cada item\footnote{\textit{Printing list.. 0,1,2,3,4,5,6,7,8,9}}.

No teste do \textit{OpenOCD}, foi utilizado um projeto exemplo de piscar o LED da placa de desenvolvimento EK-LM4F232 (Algoritmo 6.4).

\lstinputlisting[language=C++,caption={blinky.c},label=blink2]{blink2.cpp}

O Código foi compilado e enviado para a placa, tendo como resultado o piscar do LED.

Foi feito um teste com o Algoritmo 6.4, onde mostrou uma precisão maior no cálculo do que o Arduino\footnote{Maior que $99.99999\%$.}, por utilizar uma FPU e uma resolução maior em bits (32).

\lstinputlisting[language=C++,caption={sin2.c},label=sin2]{sin2.c}

Pela placa EK-4F232 conter poucos usuários e uma base de desenvolvimento em C puro com inúmeras dependências, testes com envio de dados pela serial não foram possíveis.

\subsection{Depuração}
Entre os sistemas suportados, o \textit{OpenOCD} é o único que tem suporte a depuração de sistemas embarcados. Para realizar tal operação é necessário manter o \textit{OpenOCD} enquanto a conexão do GDB é realizada.

Certos problemas foram encontrados durante o procedimento de depuração, fazendo com que o KDevelop finalizasse com erro. Tal problema foi reportado e é conhecido pela comunidade nas utilizações do KDevelop para depuração remota, futuras versões do programa irão corrigir o problema.

\chapter{Conclusão}
Dentro do período de desenvolvimento, o plugin alcançou todas as expectativas traçadas,
permitindo a gravação dos sistemas embarcados utilizando o KDevelop, mesmo necessitando algumas modificações para ficar
totalmente integrado ao fluxo de trabalho.

A integração com o KDevelop foi realizada com sucesso, necessitando que o usuário configure algumas variáveis para permitir identificar o hardware utilizado pelo mesmo, tanto o processador quanto o hardware especialista ou assistencialista na realização do envio do código binário.

O código fonte do projeto desenvolvido pode ser encontrado no \textit{mirror} do \textit{GitHub} (\url{https://github.com/KDE/kdev-embedded/tree/master}) ou no repositório oficial do \textit{phabricator} (\url{https://phabricator.kde.org/source/kdev-embedded/browse/master/}).

Tendo em vista que com o suporte para as placas da \textit{Arduino} e do sistema \textit{OpenOCD} realizado, ainda é necessário mais alguns trabalhos relacionados a áreas especificas.

As interfaces desenvolvidas foram trabalhadas para serem a mais ami-gáveis e altamente configuráveis na medida do possível, contudo, ainda é necessário um polimento e melhor desenvolvimento tanto da interface do plugin quanto do KDevelop, para permitir uma melhor integração com o usuário, facilitando algumas configurações básicas como a já existentes no \textit{eclipse IDE} para \textit{debug} remoto.

Mesmo o instalador sendo completamente funcional, identificando ver-sões instaladas no sistema operacional e
permitindo ao usuário realizar a instalação automática das dependências, com a ajuda da interface gráfica disponível pelo plugin, o mesmo não é de muita ajuda para os usuários avançados.

A integração do plugin desenvolvido com os demais plugins do KDevelop necessita ser melhor integrado e aprimorada, permitindo desta
forma a integração com os gerenciadores de montagem de software.

Atualmente o plugin utiliza uma biblioteca desenvolvida pela comunidade do KDE conhecida como \textit{Solid}, onde permite uma boa integração com o \textit{hardwre} do computador onde o mesmo está sendo executado. Contudo o mesmo tem problemas para identificação de gravadores que não utilizam um adaptador Adaptador Serial-USB, dificultando sua utilização. 

Como proposta de solução, é utilizar os valores de PID e VID dos dispositivos conhecidos na realização da gravação, podendo ser obtidos através das bibliotecas do \textit{OpenOCD}, para melhorar sua utilização na detecção de hardware.

\abreviatura{PID}{\textit{Product ID}}
\abreviatura{VID}{\textit{Vendor ID}}
